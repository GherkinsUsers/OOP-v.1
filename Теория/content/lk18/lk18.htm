<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../css/styles.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title>Тема №18</title>
    <base target="_top">
</HEAD>

<BODY>
    <div class="title-1">
        Исключения в языке C++
    </div>
    <div class="content">

        <div class="title-2">
            18.1 Апплеты.
        </div>
        <p>Исключениями называют аномальные ситуации, возникающие во время исполнения программы: невозможность открыть нужный
            файл или получить необходимое количество памяти, использование выходящего за границы индекса для какого-либо
            массива. Обработка такого рода исключений, как правило, плохо интегрируется в основной алгоритм программы, и
            программисты вынуждены изобретать разные способы корректной обработки исключения, стараясь в то же время не слишком
            усложнить программу добавлением всевозможных проверок и дополнительных ветвей алгоритма.</p>
        <p>С++ предоставляет стандартный способ реакции на исключения. Благодаря вынесению в отдельную часть программы кода,
            ответственного за проверку и обработку ошибок, значительно облегчается восприятие текста программы и сокращается
            ее размер. Единый синтаксис и стиль обработки исключений можно, тем не менее, приспособить к самым разнообразным
            нуждам и запросам.</p>
        <p>Механизм исключений делится на две основные части:</p>
        <p>точка программы, в которой произошло исключение. Определение того факта, что при выполнении возникла какая-либо ошибка,
            влечет за собой возбуждение исключения. Для этого в С++ предусмотрен специальный оператор throw. Возбуждение
            исключения в случае невозможности открыть некоторый файл выглядит следующим образом:</p>
        <p>

            if ( !infile ) {




            <p>string errMsg("Невозможно открыть файл: ");</p>
            <p>errMsg += fileName;</p>
            <p>throw errMsg;</p>
            <p>}</p>
            <p>Место программы, в котором исключение обрабатывается. При возбуждении исключения нормальное выполнение программы
                приостанавливается и управление передается обработчику исключения. Поиск нужного обработчика часто включает
                в себя раскрутку так называемого стека вызовов программы. После обработки исключения выполнение программы
                возобновляется, но не с того места, где произошло исключение, а с точки, следующей за обработчиком. Для определения
                обработчика исключения в С++ используется ключевое слово catch Вот как может выглядеть обработчик для примера
                из предыдущего абзаца:

            </p>
            <p>

                catch (string exceptionMsg)</p>
            <p> { log_message (exceptionMsg)</p>
            <p>return false;</p>
            <p>}</p>
            <p>Каждый catch-обработчик ассоциирован с исключениями, возникающими в блоке операторов, который непосредственно предшествует обработчику и помечен ключевым словом try. Одному try-блоку могут соответствовать несколько catch-предложений, каждое из которых относится к определенному виду исключений. Приведем пример:</p>
            <p>int* stats (const int *ia, int size){</p>
            <p>int *pstats = new int [4];</p>
            <p>try {</p>
            <p>pstats[0] = sum_it (ia,size);</p>
            <p>pstats[1] = min_val (ia,size);</p>
            <p>pstats[2] = max_val (ia,size);</p>
            <p>}</p>
            <p>  catch (string exceptionMsg) {
                // код обработчика</p>
            <p>}</p>
            <p>catch (const statsException &statsExcp) {
                // код обработчика</p>
            <p>}</p>
            <p>pstats [3] = pstats[0] / size;</p>
            <p>do_something (pstats);</p>
            <p>return pstats;
            }</p>

            <div class="title-2">
                Понятие автоматического указателя
            </div>
            <p>Класс auto_ptr – это шаблонный класс для контроля над распределением динамической памяти.</p>
            <p>void remodel ( string & str)

                {</p>
            <p>string * ps = new string(str) ;</p>
            <p>str = ps ;</p>
            <p>return ;</p>
            <p>При каждом вызове функции происходит выделение памяти в куче, однако память не освобождается. Это приводит к утечкам памяти. Решение проблемы очевидно – не забыть освободить память:</p>
            <p></p>

</BODY>

</HTML>