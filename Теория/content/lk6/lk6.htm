<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
  <LINK rel=stylesheet href="../../css/styles.css" type=text/css>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
  <META HTTP-EQUIV="Content-Language" CONTENT="ru">
  <title>Тема №6</title>
  <base target="_top">
</HEAD>

<BODY>
  <div class="title-1">
    Виртуальный метод и виртуальное свойство
  </div>
  <div class="content">
    <p> Виртуальный метод (виртуальная функция) — в объектно-ориентированном программировании метод (функция) класса, который
      может быть переопределён в классах-наследниках так, что конкретная реализация метода для вызова будет определяться
      во время исполнения. Таким образом, программисту необязательно знать точный тип объекта для работы с ним через виртуальные
      методы: достаточно лишь знать, что объект принадлежит классу или наследнику класса, в котором метод объявлен. Одним
      из переводов слова virtual с английского языка может быть «фактический», что больше подходит по смыслу.</p>

    <p>Виртуальные методы — один из важнейших приёмов реализации полиморфизма. Они позволяют создавать общий код, который может
      работать как с объектами базового класса, так и с объектами любого его класса-наследника. При этом базовый класс определяет
      способ работы с объектами и любые его наследники могут предоставлять конкретную реализацию этого способа.</p>

    <p>Одни языки программирования (например, C++, C#) требуют явно указывать, что данный метод является виртуальным. В других
      языках (например, Java, Python) все методы являются виртуальными по умолчанию (но только те методы, для которых это
      возможно; например в Java методы с доступом private не могут быть переопределены в связи с правилами видимости).</p>

    <p>Базовый класс может и не предоставлять реализации виртуального метода, а только декларировать его существование. Такие
      методы без реализации называются «чистыми виртуальными» (перевод англ. pure virtual) или абстрактными. Класс, содержащий
      хотя бы один такой метод, тоже будет абстрактным. Объект такого класса создать нельзя (в некоторых языках допускается,
      но вызов абстрактного метода приведёт к ошибке). Наследники абстрактного класса должны предоставить реализацию для
      всех его абстрактных методов, иначе они, в свою очередь, будут абстрактными классами. Абстрактный класс, который содержит
      только абстрактные методы, называется интерфейсом.</p>

    <p>Для каждого класса, имеющего хотя бы один виртуальный метод, создаётся таблица виртуальных методов. Каждый объект хранит
      указатель на таблицу своего класса. Для вызова виртуального метода используется такой механизм: из объекта берётся
      указатель на соответствующую таблицу виртуальных методов, а из неё, по фиксированному смещению, — указатель на реализацию
      метода, используемого для данного класса. При использовании множественного наследования ситуация несколько усложняется
      за счёт того, что таблица виртуальных методов становится нелинейной.</p>

    <div class="title-1"> Пример аналога виртуальных функций в PHP</div>
    <p>Аналогом в PHP можно считать использование позднего статического связывания.

      <p>class Foo {</p>
      <p> public static function baz() {</p>
      <p> return 'вода';</p>
      <p>}</p>
      <p>public function __construct() {</p>
      <p> echo static::baz(); // позднее статическое связывание</p>
      <p> }</p>
      <p>}</p>

      <p>class Bar extends Foo {</p>
      <p>public static function baz() {</p>
      <p> return 'огонь';</p>
      <p>}</p>
      <p>}</p>

      <p>new Foo(); // выведет 'вода'</p>
      <p>new Bar(); // выведет 'огонь'</p>
      <div class="title-2">Абстрактный виртуальный метод.</div>
      <p>Абстра?ктный ме?тод (или чистый виртуальный метод (pure virtual method — часто неверно переводится как чИсто виртуальный
        метод)) — в объектно-ориентированном программировании, метод класса, реализация для которого отсутствует. Класс,
        содержащий абстрактные методы, также принято называть абстрактным (там же и пример). Абстрактные методы зачастую
        путают с виртуальными. Абстрактный метод подлежит определению в классах-наследниках, поэтому его можно отнести к
        виртуальным, но не каждый виртуальный метод является абстрактным.</p>
      <div class="title-2">Динамические методы.</div>
      <p>Динамические методы вызываются медленнее виртуальных, но позволяют более экономно расходовать память. Каждому динамическому
        методу присваивается индекс — отрицательное число. В таблице динамических методов (Dynamic Method Table, DMT) класса
        хранятся индексы и адреса только тех динамических методов, которые описаны в данном классе. Если в DMT данного класса
        адрес нужного динамического метода не находится, то просматривается DMT класса-предка, и так далее по всей цепочке
        наследования до класса TObject. Таким образом, доступ к методу через DMT может привести к активному поиску в DMT
        разных классов и потребовать сотен тактов процессора.</p>
      <p>Во всем остальном между виртуальными и динамическими методами нет принципиальной разницы.</p>
      <p>Динамические методы используются для редко вызываемых методов, когда потерями в производительности можно пренебречь.
        Синтаксис объявления динамических методов:</p>
      <p> Procedure
        <имя метода>[(
          <параметры>)}; Dynamic;</p>
      <p> Function
        <имя метода>[(
          <параметры>)}:
            <тип результата>; Dynamic;</p>
      <div class="title-2">Полиморфизм».</div>
      <p>Полиморфизм — одна из трех основных парадигм ООП. Если говорить кратко, полиморфизм — это способность обьекта использовать
        методы производного класса, который не существует на момент создания базового. Для тех, кто не особо сведущ в ООП,
        это, наверно, звучит сложно. Поэтому рассмотрим применение полиморфизма на примере.
      </p>
      <div class="title-2">Запрет на расширение</div>
      <p>Наследование от класса можно запретить с помощью ключевого слова sealed – «запечатанный». «Запечатывание» позволяет компилятору в некоторых случаях построить более производительный программный код. Например, вызовы всех виртуальных методов «запечатанного» класса можно выполнять так, будто они не виртуальные. Это дает некоторый выигрыш в производительности. Пример «запечатанного класса»:
      </p>
   <p>   public sealed class DelimitedReader : TableReader</p>
   <p> {</p>
    <p>  ...</p>
    <p> }</p>
    <p> «Запечатать» можно отдельный виртуальный метод класса:</p>
      <p>public class TableReader</p>
<p>{</p>
  <p> public virtual bool NextLine() { ... }</p>
  <p>}</p>

  <p>public class DelimitedReader : TableReader</p>
  <p>{</p>
    <p>  public sealed override bool NextLine() { ... }</p>
    <p>}</p>


</BODY>

</HTML>