<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
    <LINK rel=stylesheet href="../../css/styles.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title>Тема №14</title>
    <base target="_top">
</HEAD>
<BODY>
  <div class="title-1">
    Визуальное компонентное и сборочное программирование
</div>
<div class="content">

    <div class="title-2">
        Понятие компонента
    </div>
    <p>Понятие компонента является фундаментальным для среды Delphi. Без компонентов все преимущества визуальной разработки приложений исчезают и говорить становится не о чем. Поэтому соберите все силы и внимательно прочитайте этот параграф, пытаясь усвоить не только технику использования компонентов, но и саму их суть.</p>
    <p>Существует два взгляда на компоненты.</p>
    <p> Взгляд снаружи, точнее из среды визуальной разработки приложений. С этой точки зрения компоненты — это самодостаточные строительные блоки, которые вы берете из палитры компонентов и переносите на форму для создания собственно приложения. Примеры компонентов вам известны: это кнопки, списки, надписи и др.</p>
    <p>Существует еще и взгляд изнутри, т.е. взгляд из программы на языке Delphi. С этой точки зрения компоненты — это классы, порожденные прямо или косвенно от класса TComponent и имеющие published-свойства. Экземпляры компонентов — это объекты этих классов, существующие в качестве полей формы. Среди опубликованных свойств компонентов обязательно присутствует имя (Name), под которым экземпляр компонента представляется в окне свойств.</p>
    <p>Объединение этих двух точек зрения дает цельное представление о том, что такое компоненты. При работе с компонентами из среды визуальной разработки приложений вы всегда видите их лицевую сторону. Однако как только вы начинаете писать обработчики событий, и управлять компонентами программно, вы соприкасаетесь с программной стороной компонентов, суть которой — объекты. Таким образом, среда Delphi обеспечивает симбиоз визуального и объектно-ориентированного программирования.</p>
    <p>При анализе структуры компонента обнаруживается, что его природа троична и лучше всего описывается формулой:</p>
    <p>Компонент = состояние (свойства) + поведение (методы) + обратная реакция (события).Компонент = состояние (свойства) + поведение (методы) + обратная реакция (события).</p>
    <p>Состояние компонента определяется его свойствами. Свойства бывают изменяемые (для чтения и записи) и неизменяемые (только для чтения). Помимо этого, свойства могут получать значения либо на этапе проектирования (design-time), либо только во время выполнения программы (run-time). Первые устанавливаются для каждого компонента в окне свойств и определяют начальное состояние компонента. Во время выполнения приложения эти свойства могут быть изменены программно, соответственно изменится внешний вид и поведение компонента. Вторая группа — это свойства, которые не видны в окне свойств, и управлять которыми можно только программно. С точки зрения языка Delphi различие между этими группами свойств состоит в том, что первые объявлены в секции published, а вторые — в секции public.</p>
    <p>Поведение компонента описывается с помощью его процедур и функций (методов). Вызовы методов компонента помещаются в исходный код программы и происходят только во время выполнения приложения. Методы не имеют под собой визуальной основы</p>
    <p>Обратная реакция компонента — это его события. События позволяют, например, связать нажатие кнопки с вызовом метода формы. События реализуются с помощью свойств, содержащих указатели на методы</p>
    <div class="title-2">
        Визуальные и невизуальные компоненты
    </div>
    <p>Все компоненты делятся на две группы: визуальные и невизуальные компоненты</p>
    <p>Визуальные компоненты (visual components) — это видимые элементы пользовательского интерфейса: кнопки, метки, блоки списков и др. Они выглядят одинаково и на стадии проектирования, и во время работы приложения.</p>
    <p>Невизуальные компоненты (non-visual components) — это, так сказать, бойцы невидимого фронта; они работают, но сами на экране не видны. К невизуальным компонентам относятся таймер, компоненты доступа к базам данным и др. В процессе проектирования такие компоненты представляются на форме небольшим значком. Их свойства устанавливаются в уже известном вам окне свойств. Некоторые компоненты хоть и являются невизуальными, могут что-нибудь отображать на экране. Например, невизуальный компонент MainMenu отображает на форме полосу главного меню, а компонент OpenDialog — стандартное диалоговое окно выбора файла.</p>
    <p>Невизуальные компоненты могут иметь подписи. Отображение подписей обеспечивается установкой переключателя Show component captions в окне Environment Options на вкладке Designer. Окно вызывается по команде меню Tools | Environment Options</p>
    <div class="title-2">
        Расширяемое программирование
    </div>
    <p>Расширяемое программирование - термин, использованный в информатике, чтобы описать стиль программирования, которое сосредотачивается на механизмах, чтобы расширить язык программирования, компилятор и окружающую среду во время выполнения. Расширяемые языки программирования, поддерживая этот стиль программирования, были активной областью работы в 1960-х, но движение было маргинализовано в 1970-х. Расширяемое программирование стало темой возобновившегося интереса в 21-м веке.</p>
    <div class="title-2">
        Расширяемый синтаксис
    </div>
    <p>Это просто означает, что исходный язык (и), который будет собран, не должен быть закрыт, фиксирован или статичный. Должно быть возможно добавить новые ключевые слова, понятия и структуры на исходный язык (и). Языки, которые позволяют добавление конструкций с определенным синтаксисом пользователя, включают Camlp4, OpenC ++, Seed7, Красный, Ребол и Феликс. В то время как приемлемо для некоторых фундаментальных и внутренних языковых особенностей быть неизменным, система не должна полагаться исключительно на те языковые особенности. Должно быть возможно добавить новые.</p>
    <div class="title-2">
        Расширяемый компилятор
    </div>
    <p></p>
    <p>В расширяемом программировании компилятор не монолитная программа, которая преобразовывает вход исходного кода в двойную выполнимую продукцию. Сам компилятор должен быть расширяем до такой степени, что это - действительно коллекция плагинов, которые помогают с переводом входа исходного языка во что-либо. Например, расширяемый компилятор поддержит поколение кодекса объекта, кодовой документации, переформатированного исходного кода или любой другой желаемой продукции. Архитектура компилятора должна разрешить его пользователям «проникать внутрь» процесса компиляции и обеспечивать альтернативные задачи обработки в каждом разумном шаге в процессе компиляции.</p>
    <p>Для просто задачи перевода исходного кода во что-то, что может быть выполнено на компьютере, должен расширяемый компилятор:</p>
    <p>используйте программное расширение или составляющую архитектуру для почти каждого аспекта ее функции
        </p>
    <p>определите, какой языковой или языковой вариант собирается, и определите местонахождение соответствующего программного расширения, чтобы признать и утвердить тот язык
    </p>
    <p>используйте формальные языковые технические требования для синтаксически и структурно утвердите произвольные исходные языки
    </p>
    <p>помогите с семантической проверкой произвольных исходных языков, призвав соответствующее программное расширение проверки
    </p>
    <p>позвольте пользователям выбирать из различных видов генераторов объектного кода так, чтобы получающееся выполнимое могло быть предназначено для различных процессоров, операционных систем, виртуальных машин или другой окружающей среды выполнения.
    </p>
    <p>предоставьте средства для ошибочного поколения и расширений к нему
    </p>
    <p>позвольте новые виды узлов в абстрактном дереве синтаксиса (AST),
    </p>
    <p>позвольте новые ценности в узлах AST,
    </p>
    <p>позвольте новые виды краев между узлами,
    </p>
    <p>поддержите преобразование входа AST или части этого, некоторым внешним «проходом»
    </p>
    <p>поддержите перевод входа AST или части этого, в другую форму некоторым внешним «проходом»
    </p>
    <p>помогите с потоком информации между внутренними и внешними проходами, поскольку они оба преобразовывают и переводят AST на новый ASTs или другие представления
    </p>
    <div class="title-2">
        Расширяемое время выполнения
    </div>
    <p>Во времени выполнения расширяемые программные системы должны разрешить языкам расширять набор операций, которые это разрешает. Например, если система использует переводчика кодекса байта, она должна позволить новым кодовым обозначениям байта быть определенными. Как с расширяемым синтаксисом, приемлемо для там быть некоторым (небольшим) набором фундаментальных или внутренних операций, которые являются неизменными. Однако должно быть возможно перегрузить или увеличить те внутренние операции так, чтобы новое или дополнительное поведение могло быть поддержано.</p>
    <div class="title-2">
        Содержание отделилось от формы
    </div>
    <p>Расширяемые программные системы должны расценить программы как данные, которые будут обработаны. Те программы должны быть абсолютно лишены любого вида форматирования информации. Визуальный показ и редактирование программ пользователям должны быть функцией перевода, поддержанной расширяемым компилятором, который переводит данные о программе на формы, более подходящие для просмотра или редактирования. Естественно, это должно быть двухсторонним переводом. Это важно, потому что должно быть возможно легко обработать расширяемые программы во множестве путей. Недопустимо для единственного использования входа исходного языка отредактировать, рассматривая и перевод на машинный код. Произвольная обработка программ облегчена, расцепив исходный вход от технических требований того, как это должно быть обработано (отформатированный, сохраненный, показанный, отредактированный, и т.д.).</p>
    <div class="title-2">
        Поддержка отладки исходного языка
    </div>
    <p>Расширяемые программные системы должны поддержать отладку программ, используя конструкции языка первоисточника независимо от расширений или преобразования, которому подверглась программа, чтобы сделать его выполнимым. Прежде всего нельзя предположить, что единственный способ показать данные во время выполнения находится в структурах или множествах. Отладчик, или более правильно 'инспектор программы', должен разрешить показ данных во время выполнения в формах, подходящих для исходного языка. Например, если язык поддерживает структуру данных для бизнес-процесса или производственного потока, для отладчика должно быть возможно показать ту структуру данных как диаграмму рыбной кости или другую форму, обеспеченную плагином.</p>
   
    


</BODY>
</HTML>